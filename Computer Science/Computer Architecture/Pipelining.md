#### 단일 사이클 구현은 오늘날 왜 사용되지 않는가?
- 비효율적
- 클럭 사이클이 모든 명령어에 대해 같은 길이를 가져야하기 때문에 비효율적
	- 최약의 지연과 같다고 가정해야함
		-> '자주 생기는 일을 빠르게' 의 원칙에 위배
- 클럭 사이클이 너무 길기 때문에 전체 성능에 좋지 않음
	- CPI 값이 1이라도
- 한 클럭 사이클 시간 자체를 개선하지 못함
	- Clock Period 자체를 줄이는 것은 힘듬

#### Pipelining 개요
- 여러 명령어가 중첩되어 실행되는 구현 기술
	![[스크린샷 2025-03-04 오후 9.47.39.png]]
	- 하나의 빨래감을 처리하는 것은 더 빨라지지 않음
	- Pipelining은 일감이 많을 때, ==병렬적으로 처리를 하여 처리량을 높이는 것!==
	- 시작 시간과 마무리 시간에는 Pipeline이 완전히 차 있지 않아 시간에 영향을 줌
		  -> 일감의 수가 훨씬 커진다면, 크게 영향을 안줌

#### MIPS Pipeline의 5단계
1. IF(Instruction Fetch): 메모리에서 명령어를 가져옴(어떤 연산을 수행해야 하는지에 대한 정보)
2. ID(Instruction Decode): 명령어를 해독하는 동시에 레지스터를 읽음(어떤 데이터를 이용해야하는지 분석)
3. EX(Execute): 연산을 수행하거나 주소를 계산함
4. MEM(Memory): 데이터 메모리에 있는 피연산자에 접근함
5. WB(Write-Back): 결과값을 레지스터에 씀

#### Pipelining을 위한 MIPS 명령어 집합 설계
1. 모든 MIPS 명령어는 같은 길이를 가짐(32-bit)
	- 명령어 Fetch와 Decode를 훨씬 쉽게 해줌
2. MIPS는 몇 가지 안되는 명령어 형식을 가지고 있음
	- 모든 명령어에서 근원지 레지스터 필드는 같은 위치(대칭성)
	  -> 명령어 해독 단계에서 하드웨어가 어떤 종류의 명령어가 인출되었는지를 결정하는 동안, 레지스터 파일 읽기를 동시에 할 수 있게 됨
3. MIPS에서는 메모리 피연산자가 적재와 저장 명령어에서만 나타남
	- 메모리 주소를 계산하기 위해 실행 단계를 사용하고 다음 단계에서 메모리에 접근할 수 있음
4. MIPS 피연산자는 메모리에 정렬되어 있어야함
	- 한 데이터 전송 명령어 때문에 메모리 접근을 두 번 하는 경우는 없음
	- 프로세서와 메모리 사이의 데이터 전송은 항상 파이프라인 단계 하나에서 처리됨
#### [[Pipeline Hazard]]
- 다음 명령어가 다음 클럭 사이클에 실행될 수 없는 상황
- 이전 단계로 인해 다음 단계 명령을 실행 못하는 경우